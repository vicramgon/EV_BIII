%\section{Implementación}


\justify


En este apartado describiremos la implementación concreta realizada de la metodología previamente propuesta, concretando cada una de las etapas y procesos. En el \hyperref[alg:1]{\textit{algoritmo 1}} se presenta el pseudocódigo del marco general de desarrollo, del algoritmo. En los puntos esta sección concretaremos cada una de las partes del mismo, dando los detalles de implementación correspondientes.\\

\subsection{Datos de entrada}

Como se propone en la metodología los datos de entrada corresponden a:\\

\begin{itemize}
    \item \textbf{Funciones objetivo $f_1, \dots, f_m$}:  Dadas como una lista de longitud $m$ de funciones, que reciban como entrada un indivividuo (vector $p-dimensional$) y devuelvan una valor real correspondiente a la valoración del individuo respecto de dicha función.\\
\end{itemize}

\noindent\begin{minipage}[H]{0.5\linewidth}
\begin{itemize}
	\item \textbf{Restricciones $g_1, \dots, g_n$}:  Dadas como una lista de longitud $n$ de funciones, que reciban como entrada un indivividuo (vector $p-dimensional$) y devuelvan una valor real correspondiente a la valoración del individuo respecto de dicha función.\\
	
    \item \textbf{El espacio de búsqueda $\Omega$}: Que establece para cada una de las variables los límites de variación (continua) de la variable. De forma que dichos límites se darán como una lista de longitud $p$ de pares ($x_{Lj}, x_{Uj}$) de valores reales. Dichos pares son ordenados para asegurar que $x_{Lj} \leq x_{Uj}$.\\
     
     \item \textbf{Número de subproblemas $N$}: Un entero que corresponde al número de subproblemas considerados, esto es el número de vectores de pesos $\boldsymbol{\lambda_i}$ y el tamaño considerado para la población.\\
     
     \item \textbf{Número de generaciones $G$}:  Un entero que corresponde al número de máximo de iteraciones llevadas a cabo por el algoritmo.\\
    
    \item \textbf{Número de vecinos $T$}: Un entero correspondiente al número de subproblemas, incluyéndose a sí mismo, que serán considerados parte de la vecindad.\\
    
\end{itemize} 


\subsection{Inicialización}

Durante la fase de inicialización se establecen los valores iniciales para:\\

\begin{itemize}
\item\textbf{ Vectores de pesos $(\boldsymbol{\lambda_1}, \dots, \boldsymbol{\lambda_N})$}, de forma que si el problema es bi-objetivo dichos vectores son generados utilizando la expresión $\boldsymbol{\lambda_i} = \left(\frac{i-1}{N-1}, \frac{N-i}{N-1} \right)$ con $i \in \{1, \dots, N\}$ para $i=1,\dots, N$. Si se desea es posible especificar un fichero en formato \textit{ASCII} del que se leerán las $N$ primeras lineas que deberán contener los vectores de pesos considerados.\\

\end{itemize}

\end{minipage} \hfill
\begin{minipage}[H]{0.47\linewidth}
    \begin{algorithm}[H]
\SetAlgoLined
 \textbf{Entrada}:
 \begin{itemize}
 
     \vspace{0.15cm}\item MOP: 
     \begin{itemize}
         \vspace{0.15cm}\item[] $\boldsymbol{F}=[f_1, \dots, f_m]$
         \vspace{0.15cm}\item[] $\boldsymbol{C} =[g_1, \dots, g_n]$
         \vspace{0.15cm}\item[] $\Omega =[(x_{L1}, x_{U1}), \dots, (x_{Lp}, x_{Up})]$
     \end{itemize}
     
    \vspace{0.15cm}\item $N$: número de subproblemas
     
    \vspace{0.15cm}\item $G$: número de generaciones
     
    \vspace{0.15cm}\item $T$: número de vecinos

    \vspace{0.15cm}\item $EOP$: operador evolutivo

    \vspace{0.15cm}\item $UN$: Updations number

    \vspace{0.15cm}\item $NDS$: Usar/no usar NDS.

 \end{itemize}
 
 \vspace{0.3cm}
  
 \textbf{Inicialización}:
    \begin{itemize}
        \vspace{0.15cm}\item $\boldsymbol{\lambda}$. Vectores de pesos $(\lambda_1, \dots, \lambda_N)$
        \vspace{0.15cm}\item $B$. Vecindad de los subproblemas $[[B_{1,1}, \dots, B_{1,T}], \dots, [B_{N,1}, \dots, B_{N,T}] ]$
        \vspace{0.15cm}\item P. Población ($\boldsymbol{I_1}, \dots, \boldsymbol{I_N}$)
        \vspace{0.15cm}\item FP. Valoración de la población ($\boldsymbol{F}(P)$)
        \vspace{0.15cm}\item VP. Violación de restricciones de la población ($\boldsymbol{V}(P)$)
        \vspace{0.15cm}\item $\boldsymbol{z}$. Punto de referencia $(z_1, \dots, z_m)$
        \vspace{0.15cm}\item \textit{Conjunto de soluciones no dominadas (NDS Set)}. 
    \end{itemize}
    
\vspace{0.3cm}
  
 \textbf{Actualización} (hasta el límite $G$):\\
    \textit{Para $i=1, \dots, N$}
        \begin{itemize}
            \vspace{0.15cm}\item $\boldsymbol{y_i} \gets EOP(\boldsymbol{P_i})$
            
            \vspace{0.15cm}\item Evaluar $\boldsymbol{y}$: $\boldsymbol{F}(\boldsymbol{y})$ y $V(\boldsymbol{y})$
            \vspace{0.15cm}\item Actualizar $\boldsymbol{z}$
            \vspace{0.15cm}\item Actualizar soluciones vecinas de $i$.
            \vspace{0.15cm}\item Actualizar NDS Set
        \end{itemize}
    
     
    \vspace{0.3cm} 
    
    \textbf{Salida}:
    \begin{itemize}
        \item Aproximación al frente de Pareto. (NDS Set)
    \end{itemize}
 \caption{Marco gral. del CMOEA/D}
 \label{alg:1}
\end{algorithm}
\end{minipage}\\

\begin{itemize}

\item \textbf{Vecindad de los subproblemas $B$}. Corresponde a una lista de listas que contienen los índices considerados dentro de la vecindad de un subproblema, de forma que para cada subproblema $i$ son considerados como vecinos los $T$ cuyos vectores asociados son más cercanos a $\boldsymbol{\lambda_i}$. Para ello se crea (temporalmente) un matriz de distancias $D_{N \times N}$ tal que cuya posición $i,j$ corresponde a la distancia euclídea entre $\boldsymbol{\lambda_i}$ y $\boldsymbol{\lambda_j}$. Una vez calculada dicha matriz, el vecindario de $i$ corresponde a los $T$ $j$ con menor $d_{ij}$.\\

\item \textbf{Población $P = [\boldsymbol{I_1}, \dots, \boldsymbol{I_N}]$}. Se inicializa con valores aleatorios (dentro del espacio de búsqueda) para cada una de las variables de cada uno de los individuos. Para ello se genera una matriz $\hat{P}_{N \times p}$ de números aleatorios (entre $0$ y $1$). De forma que ahora $P$ es obtenida aplicando a cada elemento de cada columna la expresión $P_{ij}=\hat{P}_{ij} \left(x_{Uj} - x_{Lj}\right) + x_{Lj}$, obteniendo un número aleatorio entre $x_{Lj}$ y $x_{Uj}$. De forma que la población $P$ es almacenada como una matriz $P_{N \times p}$ en la que cada fila corresponde al individuo $\boldsymbol{P_i}$ asociado al problema $i$; y cada columna corresponde al valor de las características de dicho individuo (genotipo).\\

\item \textbf{Valoración de la población $FP_{N \times m} = \boldsymbol{F}(P)$}. Es inicializada con la valoración de los individuos de $P$. Para ello a cada una de los individuos (filas) de $P$ son valorados según las funciones objetivo $f_1, \dots. f_m$, dando lugar a la matriz $FP$, en la que cada fila $i$ corresponde a las valoraciones del individuo $\boldsymbol{P_i}$ (fenotipo) y cada columna $j$ a la valoración según $f_j$\\ 

\item \textbf{Violación de restricciones de la población $VP^{(N)} = V(P)$}. Es inicializada con la violación de restricciones de cada uno de los individuos de $P$. Para ello a cada una de los individuos (filas) de $P$ se les aplica $V(\boldsymbol{x})= - \sum \limits_{j=1}^{n} \min(g_j(\boldsymbol{x}), 0)$ dando lugar a un vector (o lista) de longitud $N$ con la cuantía de violación (nótese que es positivo, ya que todos los sumandos son no positivos, esto es, negativos o nulos) de cada uno de los individuos.\\ 

\item \textbf{Punto de referencia $\boldsymbol{z} = (z_1, \dots, z_m)$}. Corresponde al vector de los mejores valores encontrados para cada una de las funciones objetivo $f_1, \dots. f_m$. Teniendo en cuenta que inicialmente solo se tienen los individuos de $P$, cuyas valoraciones corresponden a $VP$, para la inicialización de $z$ basta coger el mínimo de cada columna de $FP$ que será el mejor (menor) valor encontrado hasta el momento) indistintamente de si es factible o infactible.\\

\item \textbf{Conjunto de soluciones no dominadas \textit{NDS Set}}. Corresponde al conjunto de vectores en el espacio de objetivos (valoraciones) que no son dominada por ninguna encontrada hasta el momento. Teniendo en cuenta que inicialmente solo se han encontrado las soluciones de $VP$ basta recorrer $VP$ y añadir \textit{NDS Set} aquellas que no son dominadas por ninguna otra, utilizando el concepto de Pareto-dominancia extendido. Esto es equivalente a tomar el inicialmente \textit{NDS Set} y realizar una actualización de \textit{NDS Set} con cada solución (vector fila) de $VP$. Dicha actualización se realiza según los pseudocódigos presentados en el \hyperref[alg:2]{algoritmo 2} y el \hyperref[alg:3]{algoritmo 3}\\

\begin{center}
\begin{minipage}[H]{0.8\linewidth}
    \begin{algorithm}[H]
\SetAlgoLined
 \textbf{Entrada}:
 \begin{itemize}
 
     \vspace{0.15cm}\item \textit{NDS}: $(NDS_P, NDS_F, NDS_V)$	
     
    \vspace{0.15cm}\item $\boldsymbol{x}, F^{(x)} = F(\boldsymbol{x}), V^{(x)} = V(\boldsymbol{x})$: vector de actualización
 \end{itemize}
 
 \vspace{0.3cm}
  
 \textbf{Actualización del NDS}:\\
        \begin{itemize}
        	\vspace{0.15cm}\item $NDS' \gets copy(NDS_P) \implies NDS'=(NDS'_P, NDS'_F, NDS'_V)$;
        	\vspace{0.15cm}\item \textit{Para $i=1, \dots, |NDS_P|$}:  \hspace{2.5cm} /*{\scriptsize $|NDS_P|=|NDS_F|=|NDS_V|$}*/
        	\begin{itemize}
        		\vspace{0.15cm}\item $F^{(j)} \gets NDS_F[j]$;  $V_j \gets NDS_V[j]$
            	\vspace{0.15cm}\item Si $(F^{(j)},V^{(j)}) \succ (F^{(x)}, V^{(x)})$: STOP
            	\vspace{0.15cm}\item Si $(F^{(x)}, V^{(x)}) \succ (F^{(j)},V^{(j)})$: $NDS'[j] \gets (x, F_x, V_x)$
        	\end{itemize}
        	\vspace{0.15cm}\item Devolver $NDS \gets unique(NDS')$
        \end{itemize}
    \vspace{0.3cm} 
    
    \textbf{Salida}:
    \begin{itemize}
        \item \textit{NDS} Actualizado.
    \end{itemize}
 \caption{Actualización de \textit{NDS}}
 \label{alg:2}
\end{algorithm}
\end{minipage} \\
\begin{minipage}[H]{0.8\linewidth}
    \begin{algorithm}[H]
\SetAlgoLined
 \textbf{Entrada}:
 \begin{itemize}
 
    \vspace{0.15cm}\item $s_a = (F^{(a)}, V^{(a)})$, $s_b = (F^{(b)}, V^{(b)})$
    \vspace{0.15cm}\item $m$: número de objetivos
 \end{itemize}
 
 \vspace{0.3cm}
  
 \textbf{Desarrollo}:\\
        \begin{itemize}
        	\vspace{0.15cm}\item Si $V^{(a)} < V^{(b)}$: devolver \textit{True}
        	\vspace{0.15cm}\item Si $V^{(a)} > V^{(b)}$: devolver \textit{False}
        	\vspace{0.15cm}\item Si $V^{(a)} = V^{(b)}$: 
        	\begin{itemize}
        		\vspace{0.15cm}\item Si $\exists j=1, \dots, m / F_i^{(b)} < F_i^{(a)}$: devolver \textit{False} 
            	\vspace{0.15cm}\item Si no, $\exists j=1, \dots, m / F_i^{(a)} < F_i^{(b)}$: devolver \textit{True} 
            	\vspace{0.15cm}\item Si no: devolver \textit{False}
        	\end{itemize}
        \end{itemize}
    \vspace{0.3cm} 
    
    \textbf{Salida}: Si $s_a$ domina a $s_b$: $s_a \succ s_b$
    \begin{itemize}
        \item \textit{NDS} Actualizado.
    \end{itemize}
 \caption{Dominancia Pareto extendida: $(F^{(a)}, V^{(a)}) \succ (F^{(b)}, V^{(b)})$}
 \label{alg:3}
\end{algorithm}
\end{minipage}\\
\end{center}

\end{itemize}

\subsection{Desarrollo evolutivo (iterativo)}

Una vez inicializado el algoritmo se lleva a cabo un proceso iterativo de evolución durante $G-1$ iteraciones (de forma que el algoritmo genera en total $G$ generaciones y realiza $G \cdot N$ evaluaciones. Durante cada una de las iteraciones del proceso evolutivo se lleva a cabo:

\subsubsection{Reproducción}

Consistente en la generación de los nuevos descendientes. Para ello, se pueden utilizar distintos operadores evolutivos con la condición de que devuelvan un único descendiente. Para que el algoritmo tenga un carácter más general, se propone que la función generadora de los descendientes $EOP$ sea dada al algoritmo también como entrada, aunque en la experimentación utilizaremos el operador EOP1 descrito a continuación.\\

    \noindent\begin{minipage}{\textwidth}
    
        \begin{algorithm}[H]
    \SetAlgoLined
     \vspace{0.2cm}\textbf{Entrada}:
    \begin{multicols}{2}
     \begin{itemize}
         \vspace{0.15cm}\item $i$: índice del individuo actual 
         \vspace{0.15cm}\item $P$: Población (genotipos)
         \vspace{0.15cm}\item $VP$: Valoración de la población (fenotipos)
         \vspace{0.15cm}\item $B_i$: Índices de vecinos de $i$
         \vspace{0.15cm}\item $\Omega$: Espacio de búsqueda.
         \vspace{0.15cm}\item Parámetros : 
            \begin{itemize}
                \item $Fs$ : Pool de valores para $F$ 
                \item $CR$ : Probabilidad de cruze 
                \item $PM$ : Probabilidad de mutación
                \item $SIG$ : Apertura de la mutación 
            \end{itemize} 
     \end{itemize}
    \end{multicols}
    
    \begin{multicols}{2}
     \vspace{0.2cm} \textbf{(1) Mutación de $\boldsymbol{P_i}$}: Vector mutante $\boldsymbol{\hat{y}}$.
            \begin{enumerate}
                \item $r_1, r_2, r_3, r_4, r_5 \in B_i$.
                \item $\boldsymbol{\hat{y}} \gets \boldsymbol{P_{r1}} + F \cdot (\boldsymbol{P_{r2}} - \boldsymbol{P_{r3}}) + rand \cdot (\boldsymbol{P_{r2}} - \boldsymbol{P_{r3}}) $
            \end{enumerate}
            
     \vspace{0.2cm} \textbf{(2) Cruce de $P_i$ con $\boldsymbol{\hat{y}}$}: 
            \begin{enumerate}
                \item $Cp \gets (\dots,  Cp_\delta=1, \dots) \in \{0,1\}^{p}$.
                \item $y_j \gets Cp \odot \boldsymbol{\hat{y}} +  (\boldsymbol{1}^{(p)} - Cp) \odot \boldsymbol{P_i}
                 $
            \end{enumerate}
            
    \end{multicols}
        
    \begin{multicols}{2}
    \vspace{0.2cm} \textbf{(3) Mutación de $\boldsymbol{y}$}:\\
    Para $j = 1, \dots, dim(\boldsymbol{P_i})$\\
            \begin{enumerate}
                \item Si $rand \in [0,1] < PM $: 
                \begin{enumerate}
                    \item $\sigma_j \gets |x_{Uj} - x_{Lj}|/SIG$
                    \item $y_j \gets y_j + rand \in \mathcal{N}(0, \sigma_j)$ 
                \end{enumerate}
            \end{enumerate}\columnbreak
            
        \vspace{0.2cm} \textbf{(4) Reparación de $\boldsymbol{y}$}: \\
        Para $j = 1, \dots, dim(\boldsymbol{P_i})$\\
            \begin{enumerate}
                \item $y_j \gets \min ( \max ( y_j , x_{Lj}), x_{Uj})$
            \end{enumerate}
    \end{multicols}
       
         \vspace{0.2cm}\textbf{Salida}: Descendiente $y \in \Omega$
     \caption{Pseudocódigo EOP1}
     \label{alg:4}
    \end{algorithm}
     \end{minipage}\\ \vspace{0.2cm}
    
    \noindent\textbf{EOP1}. Basado en DE + GP. En el \hyperref[alg:4]{\textit{algoritmo 4}} se presenta el pseudocódigo de la función que describimos a continuación. El operador evolutivo EOP1 toma un individuo $P_i$ y genera un desciendente $\boldsymbol{y}$ a partir de él, de forma que:\\
    
    \begin{enumerate}
        \item Realiza una primera mutación de $\boldsymbol{P_i}$ (procendente de DE) de forma que se genera un vector mutante a partir de cinco vectores escogidos del entorno de $P_i$. En concreto se escogen al azar cinco elementos del vecindario de $i$ (correspondientes a los subproblemas $r1$, $r2$. $r3$, $r4$ y $r5$, con reemplazamiento si es necesario) y se genera el vector mutante aplicando la expresión descrita a partir de los vectores asociados a los subproblemas que son justamente las filas correspondientes a los índices $r1$, $r2$ y $r3$ de la población (matriz) $P$, de forma que el vector mutante corresponde a $\boldsymbol{\hat{y}} = P_{r1} + F (P_{r2} - P_{r3})$. Con $F$ un parámetro de la función establecido por el usuario (típicamente $0.5$). \\
        
        \item Realiza el cruce del individuo $\boldsymbol{P_i}$ con el vector mutante $\boldsymbol{\hat{y}}$. Para ello se genera un vector de números aleatorios booleanos $\boldsymbol{CP}$ (crossing points) (con probabilidad $CR$, dada por el usuario, típicamente $0.5$), esto es un vector de valores $0$ y $1$, de forma que para garantizar que el vector resultante contiene al menos un elemento del vector mutante, una posición aleatoria de $CP$ es fijada a $1$. Ahora para el vector resultante (descendiente) se toman  de $\boldsymbol{\hat{y}}$ aquellas componentes en las que $CP_j = 1$ y de $\boldsymbol{P_i}$ aquellas que son $0$, esto es justamente (en operaciones vectoriales) $\boldsymbol{y} = \boldsymbol{CP} \odot \boldsymbol{\hat{y}} +  (\boldsymbol{1}^{(p)} - \boldsymbol{CP}) \odot \boldsymbol{P_i}$ (con $\boldsymbol{1}^{(p)}$ el vector $p$-dimensional con todas sus componentes  $1$).\\
        
        \item Realiza una perturbación gaussiana en algunas de las componentes del descendiente. De forma que para cada una de las componentes se sortea aleatoriamente con probabilidad $PM$ (dada por el usuario o en su ausencia $1/p$, con $p$ el número de componentes de los individuos) y en caso favorable dicha componente $y_j$ es perturbada añadiéndole una cantidad aleatoria obtenida de una distribución normal (gaussiana) de media 0 y desviación estándar $\frac{|x_{Uj} - x_{Lj}|}{SIG}$ (donde $SIG$ corresponde a un parámetro ajustable por el usuario, típicamente 20). \\
        
        \item Finalmente cada una de las componentes de $y$ que se encuentren fuera del espacio de búsqueda son ajustadas a la cota correspondiente, equivalente a aplicar la función $y_j = min(max(y_j ,x_{Lj}),$ $x_{Uj})$ sobre cada componente.\\
        
    \end{enumerate}

\subsubsection{Evaluación del descendiente}

Una vez generado el sucesor éste es evaluado respecto a cada uno de los objetivos almacenándose en un vector $\boldsymbol{f_y}$ las valoraciones tal que la posición $k$ de dicho vector corresponde a $f_k(\boldsymbol{y})$.\\

De igual forma el sucesor es evaluado respecto de las restricciones, calculándose y almacenándose $V_y = V(y)$.\\

\subsubsection{Actualización del punto de referencia}

Como $\boldsymbol{z}$ debe mantener en todo momento los mejores valores obtenidos por alguno de los individuos, es necesario actualizar aquellas componentes en las que $\boldsymbol{f_y}$ sea mejor (menor) que $\boldsymbol{z}$, de forma que para cada componente $j=1, \dots, m$, se actualiza $\boldsymbol{z}$ con $z_j = \min(z_j, (f_y)_j)$.\\

\subsubsection{Actualización de los vecinos}

A continuación se aplicará sobre el vecindario el operador de selección descrito en la metodología. Para ello se opera siguiendo el pseudocódigo presentado en el \hyperref[alg:5]{algoritmo 5}.\\

Como se ha indicado previamente la actualización de muchos de los vecinos puede llevar al algoritmo a una convergencia prematura (estancamiento) por ello se controla mediante el parámetro $UN$ el número máximo de actualizaciones.\\

\begin{center}
\begin{minipage}[H]{0.8\linewidth}
    \begin{algorithm}[H]
\SetAlgoLined
 \textbf{Entrada}:
 \begin{itemize}
 
     \vspace{0.15cm} \item $i$: el subproblema considerado.
     \vspace{0.15cm} \item $B$: la lista de vecindades. 
     \vspace{0.15cm} \item $P, FP, VP$: la población y su valoración de objetivos y restricciones.
     \vspace{0.15cm} \item $\boldsymbol{\lambda}$: la lista de vectores de pesos.
     \vspace{0.15cm} \item $z$: el vector de mejores valores objetivo.
     \vspace{0.15cm} \item $NDS$: conjunto de soluciones no dominadas.
     \vspace{0.15cm} \item $\boldsymbol{y},\boldsymbol{f_y}, V_y$: el descendiente y su valoración de objetivos y restricciones.
     \vspace{0.15cm} \item $it$: el número de generación actual.
     \vspace{0.15cm} \item $G$: el número máximo de generaciones.
 \end{itemize}
 
 \vspace{0.3cm}
  
 \textbf{Actualización de la vecindad}:\\
        \begin{itemize}
        	\vspace{0.15cm} \item $c=0$,  $\eta= 20^{\frac{it}{G}}$, $s= it < \frac{3*G}{4} ? 10^{-\frac{G}{it}} : \eta $;
        	\vspace{0.15cm}\item \textit{Para $j=1, \dots, B(i)$}:
        	\begin{itemize}
        		\vspace{0.15cm}\item $\tau= mean (\{V_x \in VP[B(j)] / V_x > 0\})$
            	\vspace{0.15cm}\item Si $V_y = 0 \wedge (V_x > 0 \vee g^{te}(\boldsymbol{y}| \lambda_j, \boldsymbol{z})$: 
            	\begin{itemize}
            		\vspace{0.15cm}\item $P[j]=\boldsymbol{y}$, $FP[j]=\boldsymbol{f_y}$, $VP[j]=V_y$
            		\vspace{0.15cm}\item $c \gets c + 1$
				\end{itemize}            	 
            	\vspace{0.15cm}\item Si no:
            	\begin{itemize}
        		\vspace{0.15cm}\item $\boldsymbol{x_e}=rand \in NDS_P$, $\boldsymbol{f_e}=(NDS_F)_{e}$, $V(e) = (NDS_V)_{e}=V(e)$
            	\vspace{0.15cm}\item $winner \gets argmin [fitness_y, fitness_j, fitness_e]$
            	\vspace{0.15cm}\item Si $winner = 1$: 
            	\begin{itemize}
            		\vspace{0.15cm}\item $P[j]=\boldsymbol{y}$, $FP[j]=\boldsymbol{f_y}$, $VP[j]=V_y$
            		\vspace{0.15cm}\item $c \gets c + 1$
				\end{itemize} 
				\vspace{0.15cm}\item Si $winner = 3$: 
				\begin{itemize}
            		\vspace{0.15cm}\item $P[j]=\boldsymbol{x_e}$, $FP[j]=\boldsymbol{f_e}$, $VP[j]=V_e$
				\end{itemize}
        	\end{itemize}
        	\end{itemize}
        	\vspace{0.15cm}\item Devolver $NDS \gets unique(NDS')$
        \end{itemize}
    \vspace{0.3cm} 
    
    \textbf{Salida}:
    \begin{itemize}
        \item \textit{NDS} Actualizado.
    \end{itemize}
 \caption{Actualización de la vecindad del subproblema $i$}
 \label{alg:5}
\end{algorithm}
\end{minipage} \\
\end{center}

\subsubsection{Actualización de \textit{NDS Set}}

Para mantener en todo el momento la consistencia del conjunto cada vez que es generado un descendiente se actualiza el conjunto añadiendo la valoración asociada y eliminando las soluciones dominadas por ella, si procede. Para ello se recorre el conjunto de soluciones dominadas, comparando cada solución con $\boldsymbol{F}(\boldsymbol{y})$ en el momento en que se encuentre una que la domine, el proceso es abortado. En caso de que no se encuentre ninguna, se habrán ido eliminando, al mismo tiempo que se recorren, aquellas soluciones dominadas por $\boldsymbol{F}(\boldsymbol{y})$, por lo que basta añadir $\boldsymbol{F}(\boldsymbol{y})$ al conjunto para completar la actualización. \\

\subsubsection{Otras cuestiones}

Nótese que el proceso de evolución (actualización de $P$ y $VP$) se realiza de forma síncrona, esto es la actualización de $P_{i}$ se realiza directamente sobre $P$ y no en una matriz auxiliar que luego sea volcada. Por ello, los individuos son recorridos en orden aleatorio en cada iteración (mediante una lista con los índices que es reordenada aleatoriamente en cada iteración) de manera que las actualizaciones influyan (probabilísticamente) igual en todos los individuos.\\

A fin de que se pueda testear el funcionamiento del algoritmo al final de cada iteración, la población (su valoración) es volcada a un fichero \textit{ASCII} en el que cada fila corresponde a un individuo y sus columnas reflejan las valoraciones del individuo y una última columna con el número de restricciones violadas. También es generado un fichero con el contenido de todas las generaciones.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



